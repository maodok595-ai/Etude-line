# üî¥ CONFIGURATION REDIS CACHE (RECOMMAND√â POUR 100K UTILISATEURS)

**Date** : 29 octobre 2025  
**Priorit√©** : üü† **FORTEMENT RECOMMAND√â**

---

## üéØ POURQUOI REDIS ?

Le cache en m√©moire (`cache_simple.py`) **ne fonctionne pas** avec Gunicorn multi-workers car :
- Chaque worker = processus s√©par√© = cache s√©par√©
- Invalidation du cache ne fonctionne que pour 1 worker sur 8
- Les 7 autres workers gardent des donn√©es obsol√®tes pendant 1 heure

**Redis r√©sout ce probl√®me** : cache partag√© entre tous les workers !

---

## üí∞ CO√õT

```
Render Redis Cache : $7/mois
```

**Impact performance** :
- Requ√™tes SQL r√©duites de **95%**
- Dashboard admin : **2s ‚Üí 0.2s** (10x plus rapide)
- Coh√©rence des donn√©es garantie

---

## üöÄ INSTALLATION SUR RENDER

### √âtape 1 : Cr√©er Redis sur Render

1. Aller sur https://dashboard.render.com
2. Cliquer sur **"New +"** ‚Üí **"Redis"**
3. Param√®tres :
   - **Name** : `etude-line-cache`
   - **Region** : `Oregon` (m√™me r√©gion que l'app)
   - **Plan** : `Starter` ($7/mois)
   - **Max Memory Policy** : `allkeys-lru` (supprime anciennes cl√©s)
4. Cliquer sur **"Create Redis"**

### √âtape 2 : R√©cup√©rer l'URL de connexion

1. Dans le dashboard Redis cr√©√©, aller dans **"Info"**
2. Copier la valeur de **"Internal Redis URL"**
   - Format : `redis://red-xxxxx:6379`
3. **NE PAS PARTAGER** cette URL (contient le mot de passe)

### √âtape 3 : Ajouter la variable d'environnement

1. Aller dans votre service web **"etude-line"**
2. **"Environment"** ‚Üí **"Add Environment Variable"**
3. Ajouter :
   - **Key** : `REDIS_URL`
   - **Value** : `redis://red-xxxxx:6379` (URL copi√©e)
4. Cliquer sur **"Save Changes"**

### √âtape 4 : Installer la biblioth√®que Redis Python

Ajouter √† `requirements.txt` :
```
redis==5.0.1
```

Puis red√©ployer sur Render (automatique apr√®s commit).

---

## üìù INT√âGRATION DANS LE CODE

### Modifier `cache_simple.py`

```python
"""
Syst√®me de cache Redis distribu√© pour Gunicorn multi-workers
Compatible avec 8 workers en production
"""

import os
from typing import Any, Optional, Dict
from datetime import datetime, timedelta
import json

try:
    import redis
    REDIS_AVAILABLE = True
except ImportError:
    REDIS_AVAILABLE = False
    print("‚ö†Ô∏è  Redis non disponible - Cache d√©sactiv√©")

class RedisCache:
    """Cache Redis distribu√© (partag√© entre tous les workers Gunicorn)"""
    
    def __init__(self, redis_url: Optional[str] = None, default_ttl: int = 300):
        """
        Args:
            redis_url: URL Redis (ex: redis://localhost:6379)
            default_ttl: Dur√©e de vie par d√©faut en secondes (300s = 5 minutes)
        """
        self.default_ttl = default_ttl
        self.redis_url = redis_url or os.getenv("REDIS_URL")
        
        if not REDIS_AVAILABLE or not self.redis_url:
            self.client = None
            print("‚ö†Ô∏è  Cache Redis d√©sactiv√© (REDIS_URL manquant)")
            return
        
        try:
            self.client = redis.from_url(
                self.redis_url,
                decode_responses=True,  # Retourne strings au lieu de bytes
                socket_connect_timeout=5,
                socket_timeout=5
            )
            # Test de connexion
            self.client.ping()
            print(f"‚úÖ Cache Redis connect√© : {self.redis_url[:20]}...")
        except Exception as e:
            self.client = None
            print(f"‚ö†Ô∏è  Erreur connexion Redis : {e}")
    
    def get(self, key: str) -> Optional[Any]:
        """R√©cup√®re une valeur du cache"""
        if not self.client:
            return None
        
        try:
            value = self.client.get(key)
            if value:
                return json.loads(value)
            return None
        except Exception as e:
            print(f"‚ö†Ô∏è  Erreur Redis get({key}): {e}")
            return None
    
    def set(self, key: str, value: Any, ttl: Optional[int] = None):
        """Stocke une valeur dans le cache avec une dur√©e de vie"""
        if not self.client:
            return
        
        try:
            ttl = ttl or self.default_ttl
            serialized = json.dumps(value)
            self.client.setex(key, ttl, serialized)
        except Exception as e:
            print(f"‚ö†Ô∏è  Erreur Redis set({key}): {e}")
    
    def delete(self, key: str):
        """Supprime une cl√© du cache (TOUS les workers verront la suppression)"""
        if not self.client:
            return
        
        try:
            self.client.delete(key)
        except Exception as e:
            print(f"‚ö†Ô∏è  Erreur Redis delete({key}): {e}")
    
    def clear(self):
        """Vide tout le cache"""
        if not self.client:
            return
        
        try:
            self.client.flushdb()
        except Exception as e:
            print(f"‚ö†Ô∏è  Erreur Redis clear: {e}")


# Instance globale du cache Redis
app_cache = RedisCache(default_ttl=300)  # 5 minutes par d√©faut

# Cl√©s de cache recommand√©es pour √âtude LINE
CACHE_KEYS = {
    "universites": "all_universites",  # TTL: 3600s (1h) - change rarement
    "ufrs": "all_ufrs",  # TTL: 3600s (1h)
    "filieres": "all_filieres",  # TTL: 3600s (1h)
    "matieres": "all_matieres",  # TTL: 1800s (30min)
}
```

### R√©activer le cache dans `main.py`

```python
def get_universites(db: Session) -> List[Dict[str, Any]]:
    """Get all universities from PostgreSQL with Redis cache (1 hour TTL)"""
    cached = app_cache.get(CACHE_KEYS["universites"])
    if cached:
        return cached
    
    universites = db.query(UniversiteDB).all()
    result = [{"id": u.id, "nom": u.nom, "code": u.code, "logo_url": u.logo_url} for u in universites]
    app_cache.set(CACHE_KEYS["universites"], result, ttl=3600)
    return result
```

R√©ajouter l'invalidation :
```python
# Apr√®s cr√©ation/modification/suppression d'universit√©
app_cache.delete(CACHE_KEYS["universites"])
```

---

## ‚úÖ V√âRIFICATION

Apr√®s d√©ploiement, v√©rifier dans les logs Render :

```
‚úÖ Cache Redis connect√© : redis://red-xxxxx...
```

Si vous voyez :
```
‚ö†Ô∏è  Cache Redis d√©sactiv√© (REDIS_URL manquant)
```

‚Üí V√©rifier que la variable `REDIS_URL` est bien configur√©e.

---

## üìä IMPACT PERFORMANCE ATTENDU

| M√©trique | Sans Redis | Avec Redis | Gain |
|----------|-----------|------------|------|
| **Dashboard Admin** | 2s | 0.2s | **10x** ‚ö° |
| **Requ√™tes SQL/sec** | 500 | 25 | **95% moins** ‚ö° |
| **Charge DB** | √âlev√©e | Faible | **20x moins** ‚ö° |
| **Coh√©rence donn√©es** | ‚ùå Non | ‚úÖ Oui | **Garanti** ‚úÖ |

---

## üéâ CONCLUSION

Redis cache est **FORTEMENT RECOMMAND√â** pour 100k utilisateurs car :
- ‚úÖ R√©sout le probl√®me de cache multi-workers
- ‚úÖ R√©duit la charge sur PostgreSQL de 95%
- ‚úÖ Garantit la coh√©rence des donn√©es
- ‚úÖ Performance 10x meilleure
- ‚úÖ Co√ªt mod√©r√© ($7/mois)

**Sans Redis** : Le syst√®me fonctionne mais moins performant  
**Avec Redis** : Performance optimale pour 100k utilisateurs ‚úÖ
